
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>auth: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/cupbot/cupbot/internal/auth/middleware.go (86.3%)</option>
				
				<option value="file1">github.com/cupbot/cupbot/internal/bot/bot.go (39.7%)</option>
				
				<option value="file2">github.com/cupbot/cupbot/internal/config/config.go (97.7%)</option>
				
				<option value="file3">github.com/cupbot/cupbot/internal/system/service.go (80.2%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package auth

import (
        "fmt"
        "log"
        "time"

        "github.com/cupbot/cupbot/internal/config"
        "github.com/cupbot/cupbot/internal/database"
        tgbotapi "github.com/go-telegram-bot-api/telegram-bot-api/v5"
)

// Middleware –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª—è–µ—Ç —Ñ—É–Ω–∫—Ü–∏–∏ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏ –∏ –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏–∏
type Middleware struct {
        config *config.Config
        db     *database.DB
}

// NewMiddleware —Å–æ–∑–¥–∞–µ—Ç –Ω–æ–≤—ã–π —ç–∫–∑–µ–º–ø–ª—è—Ä middleware
func NewMiddleware(cfg *config.Config, db *database.DB) *Middleware <span class="cov8" title="1">{
        return &amp;Middleware{
                config: cfg,
                db:     db,
        }
}</span>

// AuthorizeUser –ø—Ä–æ–≤–µ—Ä—è–µ—Ç –ø—Ä–∞–≤–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –Ω–∞ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–µ –∫–æ–º–∞–Ω–¥
func (m *Middleware) AuthorizeUser(update tgbotapi.Update) (bool, *database.User) <span class="cov8" title="1">{
        var user *tgbotapi.User
        var chatID int64

        // –ü–æ–ª—É—á–∞–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∏–∑ —Ä–∞–∑–Ω—ã—Ö —Ç–∏–ø–æ–≤ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–π
        if update.Message != nil </span><span class="cov8" title="1">{
                user = update.Message.From
                chatID = update.Message.Chat.ID
        }</span> else<span class="cov8" title="1"> if update.CallbackQuery != nil </span><span class="cov8" title="1">{
                user = update.CallbackQuery.From
                chatID = update.CallbackQuery.Message.Chat.ID
        }</span> else<span class="cov8" title="1"> {
                return false, nil
        }</span>

        <span class="cov8" title="1">if user == nil </span><span class="cov0" title="0">{
                return false, nil
        }</span>

        // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —Ä–∞–∑—Ä–µ—à–µ–Ω –ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –≤ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏
        <span class="cov8" title="1">if !m.config.IsAllowed(user.ID) </span><span class="cov8" title="1">{
                log.Printf("Unauthorized access attempt from user %d (%s)", user.ID, user.UserName)
                return false, nil
        }</span>

        // –°–æ–∑–¥–∞–µ–º –∏–ª–∏ –æ–±–Ω–æ–≤–ª—è–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –≤ –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö
        <span class="cov8" title="1">dbUser := &amp;database.User{
                ID:        user.ID,
                Username:  user.UserName,
                FirstName: user.FirstName,
                LastName:  user.LastName,
                IsAdmin:   m.config.IsAdmin(user.ID),
                IsActive:  true,
                UpdatedAt: time.Now(),
        }

        // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –≤ –ë–î
        existingUser, err := m.db.GetUser(user.ID)
        if err != nil </span><span class="cov8" title="1">{
                // –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω, —Å–æ–∑–¥–∞–µ–º –Ω–æ–≤–æ–≥–æ
                dbUser.CreatedAt = time.Now()
        }</span> else<span class="cov0" title="0"> {
                // –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Å—É—â–µ—Å—Ç–≤—É–µ—Ç, —Å–æ—Ö—Ä–∞–Ω—è–µ–º –¥–∞—Ç—É —Å–æ–∑–¥–∞–Ω–∏—è
                dbUser.CreatedAt = existingUser.CreatedAt
        }</span>

        <span class="cov8" title="1">if err := m.db.CreateOrUpdateUser(dbUser); err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to create/update user %d: %v", user.ID, err)
        }</span>

        // –û–±–Ω–æ–≤–ª—è–µ–º —Å–µ—Å—Å–∏—é –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        <span class="cov8" title="1">session := &amp;database.UserSession{
                UserID:   user.ID,
                ChatID:   chatID,
                LastSeen: time.Now(),
                IsActive: true,
        }

        if err := m.db.UpdateUserSession(session); err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to update user session %d: %v", user.ID, err)
        }</span>

        <span class="cov8" title="1">return true, dbUser</span>
}

// RequireAdmin –ø—Ä–æ–≤–µ—Ä—è–µ—Ç, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–æ–º
func (m *Middleware) RequireAdmin(userID int64) bool <span class="cov8" title="1">{
        return m.config.IsAdmin(userID)
}</span>

// LogCommand –∑–∞–ø–∏—Å—ã–≤–∞–µ—Ç –≤—ã–ø–æ–ª–Ω–µ–Ω–Ω—É—é –∫–æ–º–∞–Ω–¥—É –≤ –∏—Å—Ç–æ—Ä–∏—é
func (m *Middleware) LogCommand(userID int64, command string, args string, success bool, response string) <span class="cov8" title="1">{
        history := &amp;database.CommandHistory{
                UserID:     userID,
                Command:    command,
                Arguments:  args,
                Success:    success,
                Response:   response,
                ExecutedAt: time.Now(),
        }

        if err := m.db.AddCommandHistory(history); err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to log command for user %d: %v", userID, err)
        }</span>
}

// GetUserHistory –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –∏—Å—Ç–æ—Ä–∏—é –∫–æ–º–∞–Ω–¥ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
func (m *Middleware) GetUserHistory(userID int64, limit int) ([]*database.CommandHistory, error) <span class="cov8" title="1">{
        return m.db.GetCommandHistory(userID, limit)
}</span>

// GetAllHistory –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –≤—Å—é –∏—Å—Ç–æ—Ä–∏—é –∫–æ–º–∞–Ω–¥ (—Ç–æ–ª—å–∫–æ –¥–ª—è –∞–¥–º–∏–Ω–æ–≤)
func (m *Middleware) GetAllHistory(userID int64, limit int) ([]*database.CommandHistory, error) <span class="cov8" title="1">{
        if !m.RequireAdmin(userID) </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("access denied: admin privileges required")
        }</span>
        <span class="cov8" title="1">return m.db.GetAllCommandHistory(limit)</span>
}

// GetStats –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è (—Ç–æ–ª—å–∫–æ –¥–ª—è –∞–¥–º–∏–Ω–æ–≤)
func (m *Middleware) GetStats(userID int64) (map[string]interface{}, error) <span class="cov8" title="1">{
        if !m.RequireAdmin(userID) </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("access denied: admin privileges required")
        }</span>
        <span class="cov8" title="1">return m.db.GetStats()</span>
}

// CleanupOldData –æ—á–∏—â–∞–µ—Ç —Å—Ç–∞—Ä—ã–µ –¥–∞–Ω–Ω—ã–µ (—Ç–æ–ª—å–∫–æ –¥–ª—è –∞–¥–º–∏–Ω–æ–≤)
func (m *Middleware) CleanupOldData(userID int64, days int) error <span class="cov8" title="1">{
        if !m.RequireAdmin(userID) </span><span class="cov8" title="1">{
                return fmt.Errorf("access denied: admin privileges required")
        }</span>
        <span class="cov8" title="1">return m.db.CleanOldHistory(days)</span>
}

// GetActiveUsers –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å–ø–∏—Å–æ–∫ –∞–∫—Ç–∏–≤–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π (—Ç–æ–ª—å–∫–æ –¥–ª—è –∞–¥–º–∏–Ω–æ–≤)
func (m *Middleware) GetActiveUsers(userID int64, minutes int) ([]*database.UserSession, error) <span class="cov8" title="1">{
        if !m.RequireAdmin(userID) </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("access denied: admin privileges required")
        }</span>
        <span class="cov8" title="1">return m.db.GetActiveUsers(minutes)</span>
}

// GetAllUsers –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –≤—Å–µ—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π (—Ç–æ–ª—å–∫–æ –¥–ª—è –∞–¥–º–∏–Ω–æ–≤)
func (m *Middleware) GetAllUsers(userID int64) ([]*database.User, error) <span class="cov8" title="1">{
        if !m.RequireAdmin(userID) </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("access denied: admin privileges required")
        }</span>
        <span class="cov8" title="1">return m.db.GetAllUsers()</span>
}

// SetUserAdmin sets admin privileges for a user (admin only)
func (m *Middleware) SetUserAdmin(adminID int64, userID int64, isAdmin bool) error <span class="cov8" title="1">{
        if !m.RequireAdmin(adminID) </span><span class="cov8" title="1">{
                return fmt.Errorf("access denied: admin privileges required")
        }</span>

        // Prevent removing admin from the last admin
        <span class="cov8" title="1">if !isAdmin </span><span class="cov8" title="1">{
                admins, err := m.getAdminUsers()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if len(admins) &lt;= 1 </span><span class="cov8" title="1">{
                        return fmt.Errorf("cannot remove admin privileges: at least one admin must remain")
                }</span>
        }

        <span class="cov8" title="1">return m.db.SetUserAdmin(userID, isAdmin)</span>
}

// SetUserActive activates/deactivates a user (admin only)
func (m *Middleware) SetUserActive(adminID int64, userID int64, isActive bool) error <span class="cov8" title="1">{
        if !m.RequireAdmin(adminID) </span><span class="cov0" title="0">{
                return fmt.Errorf("access denied: admin privileges required")
        }</span>

        // Prevent deactivating the last admin
        <span class="cov8" title="1">if !isActive </span><span class="cov8" title="1">{
                user, err := m.db.GetUser(userID)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if user.IsAdmin </span><span class="cov8" title="1">{
                        admins, err := m.getActiveAdminUsers()
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">if len(admins) &lt;= 1 </span><span class="cov8" title="1">{
                                return fmt.Errorf("cannot deactivate the last active admin")
                        }</span>
                }
        }

        <span class="cov8" title="1">return m.db.SetUserActive(userID, isActive)</span>
}

// DeleteUser removes a user (admin only)
func (m *Middleware) DeleteUser(adminID int64, userID int64) error <span class="cov8" title="1">{
        if !m.RequireAdmin(adminID) </span><span class="cov0" title="0">{
                return fmt.Errorf("access denied: admin privileges required")
        }</span>

        // Prevent deleting admin users
        <span class="cov8" title="1">user, err := m.db.GetUser(userID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if user.IsAdmin </span><span class="cov8" title="1">{
                return fmt.Errorf("cannot delete admin user: remove admin privileges first")
        }</span>

        <span class="cov8" title="1">return m.db.DeleteUser(userID)</span>
}

// GetUsersByStatus gets users by status (admin only)
func (m *Middleware) GetUsersByStatus(adminID int64, isActive bool) ([]*database.User, error) <span class="cov8" title="1">{
        if !m.RequireAdmin(adminID) </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("access denied: admin privileges required")
        }</span>
        <span class="cov8" title="1">return m.db.GetUsersByStatus(isActive)</span>
}

// Helper methods
func (m *Middleware) getAdminUsers() ([]*database.User, error) <span class="cov8" title="1">{
        users, err := m.db.GetAllUsers()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var admins []*database.User
        for _, user := range users </span><span class="cov8" title="1">{
                if user.IsAdmin </span><span class="cov8" title="1">{
                        admins = append(admins, user)
                }</span>
        }
        <span class="cov8" title="1">return admins, nil</span>
}

func (m *Middleware) getActiveAdminUsers() ([]*database.User, error) <span class="cov8" title="1">{
        users, err := m.db.GetAllUsers()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var admins []*database.User
        for _, user := range users </span><span class="cov8" title="1">{
                if user.IsAdmin &amp;&amp; user.IsActive </span><span class="cov8" title="1">{
                        admins = append(admins, user)
                }</span>
        }
        <span class="cov8" title="1">return admins, nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package bot

import (
        "fmt"
        "log"
        "strings"
        "time"

        "github.com/cupbot/cupbot/internal/auth"
        "github.com/cupbot/cupbot/internal/config"
        "github.com/cupbot/cupbot/internal/database"
        "github.com/cupbot/cupbot/internal/system"
        tgbotapi "github.com/go-telegram-bot-api/telegram-bot-api/v5"
)

// Bot –ø—Ä–µ–¥—Å—Ç–∞–≤–ª—è–µ—Ç Telegram –±–æ—Ç–∞
type Bot struct {
        api           *tgbotapi.BotAPI
        config        *config.Config
        db            *database.DB
        authMw        *auth.Middleware
        systemService *system.Service
}

// New —Å–æ–∑–¥–∞–µ—Ç –Ω–æ–≤—ã–π —ç–∫–∑–µ–º–ø–ª—è—Ä –±–æ—Ç–∞
func New(cfg *config.Config, db *database.DB) (*Bot, error) <span class="cov0" title="0">{
        api, err := tgbotapi.NewBotAPI(cfg.Bot.Token)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create bot API: %w", err)
        }</span>

        <span class="cov0" title="0">api.Debug = cfg.Bot.Debug

        bot := &amp;Bot{
                api:           api,
                config:        cfg,
                db:            db,
                authMw:        auth.NewMiddleware(cfg, db),
                systemService: system.NewService(),
        }

        log.Printf("Authorized on account %s", api.Self.UserName)
        return bot, nil</span>
}

// Start –∑–∞–ø—É—Å–∫–∞–µ—Ç –±–æ—Ç–∞
func (b *Bot) Start() error <span class="cov0" title="0">{
        u := tgbotapi.NewUpdate(0)
        u.Timeout = 60

        updates := b.api.GetUpdatesChan(u)

        log.Println("Bot started. Waiting for messages...")

        for update := range updates </span><span class="cov0" title="0">{
                go b.handleUpdate(update)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Stop –æ—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç –±–æ—Ç–∞
func (b *Bot) Stop() <span class="cov0" title="0">{
        b.api.StopReceivingUpdates()
        log.Println("Bot stopped")
}</span>

// handleUpdate –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –≤—Ö–æ–¥—è—â–∏–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è
func (b *Bot) handleUpdate(update tgbotapi.Update) <span class="cov0" title="0">{
        // –ê–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        authorized, user := b.authMw.AuthorizeUser(update)
        if !authorized </span><span class="cov0" title="0">{
                b.sendUnauthorizedMessage(update)
                return
        }</span>

        <span class="cov0" title="0">if update.Message != nil </span><span class="cov0" title="0">{
                b.handleMessage(update.Message, user)
        }</span> else<span class="cov0" title="0"> if update.CallbackQuery != nil </span><span class="cov0" title="0">{
                b.handleCallbackQuery(update.CallbackQuery, user)
        }</span>
}

// handleMessage –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç —Ç–µ–∫—Å—Ç–æ–≤—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è
func (b *Bot) handleMessage(message *tgbotapi.Message, user *database.User) <span class="cov0" title="0">{
        if !message.IsCommand() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">command := message.Command()
        args := message.CommandArguments()

        log.Printf("User %d (%s) executed command: %s %s", user.ID, user.Username, command, args)

        var response string
        var success bool

        switch command </span>{
        case "start":<span class="cov0" title="0">
                response, success = b.handleStart(message, user)</span>
        case "help", "menu":<span class="cov0" title="0">
                response, success = b.handleHelp(message, user)</span>
        case "status":<span class="cov0" title="0">
                response, success = b.handleStatusInternal(user)</span>
        case "uptime":<span class="cov0" title="0">
                response, success = b.handleUptimeInternal(user)</span>
        case "history":<span class="cov0" title="0">
                response, success = b.handleHistoryInternal(user, args)</span>
        case "users":<span class="cov0" title="0">
                response, success = b.handleUsersInternal(user)</span>
        case "stats":<span class="cov0" title="0">
                response, success = b.handleStatsInternal(user)</span>
        case "cleanup":<span class="cov0" title="0">
                response, success = b.handleCleanup(message, user, args)</span>
        case "addadmin":<span class="cov0" title="0">
                response, success = b.handleAddAdmin(message, user, args)</span>
        case "removeadmin":<span class="cov0" title="0">
                response, success = b.handleRemoveAdmin(message, user, args)</span>
        case "banuser":<span class="cov0" title="0">
                response, success = b.handleBanUser(message, user, args)</span>
        case "unbanuser":<span class="cov0" title="0">
                response, success = b.handleUnbanUser(message, user, args)</span>
        case "deleteuser":<span class="cov0" title="0">
                response, success = b.handleDeleteUser(message, user, args)</span>
        default:<span class="cov0" title="0">
                response = fmt.Sprintf("–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –∫–æ–º–∞–Ω–¥–∞: %s\n–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ /help –¥–ª—è –ø—Ä–æ—Å–º–æ—Ç—Ä–∞ –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –∫–æ–º–∞–Ω–¥", command)
                success = false</span>
        }

        // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –æ—Ç–≤–µ—Ç
        <span class="cov0" title="0">if response != "" </span><span class="cov0" title="0">{
                msg := tgbotapi.NewMessage(message.Chat.ID, response)
                msg.ParseMode = tgbotapi.ModeMarkdown

                // –î–ª—è –∫–æ–º–∞–Ω–¥ help –∏ menu –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –∫–ª–∞–≤–∏–∞—Ç—É—Ä—É
                if command == "help" || command == "menu" </span><span class="cov0" title="0">{
                        msg.ReplyMarkup = b.getMainKeyboard(user.IsAdmin)
                }</span>

                <span class="cov0" title="0">if _, err := b.api.Send(msg); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Failed to send message: %v", err)
                }</span>
        }

        // –ó–∞–ø–∏—Å—ã–≤–∞–µ–º –≤ –∏—Å—Ç–æ—Ä–∏—é
        <span class="cov0" title="0">b.authMw.LogCommand(user.ID, command, args, success, response)</span>
}

// handleCallbackQuery –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç callback –∑–∞–ø—Ä–æ—Å—ã
func (b *Bot) handleCallbackQuery(callback *tgbotapi.CallbackQuery, user *database.User) <span class="cov0" title="0">{
        // –û—Ç–≤–µ—á–∞–µ–º –Ω–∞ callback
        callbackResponse := tgbotapi.NewCallback(callback.ID, "")
        b.api.Request(callbackResponse)

        var response string
        var success bool

        // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –∫–∞–ª–ª–±—ç–∫ –¥–∞–Ω–Ω—ã–µ
        switch callback.Data </span>{
        case "status":<span class="cov0" title="0">
                response, success = b.handleStatusCallback(user)</span>
        case "uptime":<span class="cov0" title="0">
                response, success = b.handleUptimeCallback(user)</span>
        case "history":<span class="cov0" title="0">
                response, success = b.handleHistoryCallback(user)</span>
        case "users":<span class="cov0" title="0">
                response, success = b.handleUsersCallback(user)</span>
        case "stats":<span class="cov0" title="0">
                response, success = b.handleStatsCallback(user)</span>
        case "admin_menu":<span class="cov0" title="0">
                response, success = b.handleAdminMenuCallback(user)</span>
        case "main_menu":<span class="cov0" title="0">
                response, success = b.handleMainMenuCallback(user)</span>
        default:<span class="cov0" title="0">
                response = "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –∫–æ–º–∞–Ω–¥–∞"
                success = false</span>
        }

        // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –æ—Ç–≤–µ—Ç
        <span class="cov0" title="0">if response != "" </span><span class="cov0" title="0">{
                msg := tgbotapi.NewMessage(callback.Message.Chat.ID, response)
                msg.ParseMode = tgbotapi.ModeMarkdown

                // –î–ª—è –º–µ–Ω—é –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –∫–ª–∞–≤–∏–∞—Ç—É—Ä—É
                if callback.Data == "main_menu" || callback.Data == "admin_menu" </span><span class="cov0" title="0">{
                        msg.ReplyMarkup = b.getMainKeyboard(user.IsAdmin)
                }</span> else<span class="cov0" title="0"> if callback.Data == "admin_menu" </span><span class="cov0" title="0">{
                        msg.ReplyMarkup = b.getAdminKeyboard()
                }</span>

                <span class="cov0" title="0">if _, err := b.api.Send(msg); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Failed to send callback response: %v", err)
                }</span>
        }

        // –ó–∞–ø–∏—Å—ã–≤–∞–µ–º –≤ –∏—Å—Ç–æ—Ä–∏—é
        <span class="cov0" title="0">b.authMw.LogCommand(user.ID, "callback:"+callback.Data, "", success, response)

        log.Printf("Callback from user %d: %s", user.ID, callback.Data)</span>
}

// sendUnauthorizedMessage –æ—Ç–ø—Ä–∞–≤–ª—è–µ—Ç —Å–æ–æ–±—â–µ–Ω–∏–µ –æ –Ω–µ–¥–æ—Å—Ç–∞—Ç–∫–µ –ø—Ä–∞–≤
func (b *Bot) sendUnauthorizedMessage(update tgbotapi.Update) <span class="cov0" title="0">{
        var chatID int64
        if update.Message != nil </span><span class="cov0" title="0">{
                chatID = update.Message.Chat.ID
        }</span> else<span class="cov0" title="0"> if update.CallbackQuery != nil </span><span class="cov0" title="0">{
                chatID = update.CallbackQuery.Message.Chat.ID
        }</span> else<span class="cov0" title="0"> {
                return
        }</span>

        <span class="cov0" title="0">msg := tgbotapi.NewMessage(chatID, "‚ùå –£ –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ –¥–ª—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è —ç—Ç–æ–≥–æ –±–æ—Ç–∞.")
        b.api.Send(msg)</span>
}

// handleStart –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –∫–æ–º–∞–Ω–¥—É /start
func (b *Bot) handleStart(message *tgbotapi.Message, user *database.User) (string, bool) <span class="cov0" title="0">{
        welcome := fmt.Sprintf(`ü§ñ *–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ CupBot!*

–ü—Ä–∏–≤–µ—Ç, %s! –≠—Ç–æ—Ç –±–æ—Ç –ø–æ–∑–≤–æ–ª—è–µ—Ç —É–¥–∞–ª–µ–Ω–Ω–æ —É–ø—Ä–∞–≤–ª—è—Ç—å –∫–æ–º–ø—å—é—Ç–µ—Ä–æ–º.

üìä *–û—Å–Ω–æ–≤–Ω—ã–µ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏:*
‚Ä¢ –ü—Ä–æ—Å–º–æ—Ç—Ä —Å—Ç–∞—Ç—É—Å–∞ —Å–∏—Å—Ç–µ–º—ã
‚Ä¢ –ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ –≤—Ä–µ–º–µ–Ω–∏ —Ä–∞–±–æ—Ç—ã
‚Ä¢ –ü—Ä–æ—Å–º–æ—Ç—Ä –∏—Å—Ç–æ—Ä–∏–∏ –∫–æ–º–∞–Ω–¥`, user.FirstName)

        if user.IsAdmin </span><span class="cov0" title="0">{
                welcome += `

üîë *–í—ã ‚Äî –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä!*
‚Ä¢ –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º–∏
‚Ä¢ –ü—Ä–æ—Å–º–æ—Ç—Ä —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏
‚Ä¢ –û—á–∏—Å—Ç–∫–∞ –¥–∞–Ω–Ω—ã—Ö`
        }</span>

        <span class="cov0" title="0">welcome += `

üì± *–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–Ω–æ–ø–∫–∏ –Ω–∏–∂–µ –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è:*`

        // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ —Å –∫–ª–∞–≤–∏–∞—Ç—É—Ä–æ–π
        msg := tgbotapi.NewMessage(message.Chat.ID, welcome)
        msg.ParseMode = tgbotapi.ModeMarkdown
        msg.ReplyMarkup = b.getMainKeyboard(user.IsAdmin)
        b.api.Send(msg)

        return "", true</span> // –ü—É—Å—Ç–æ–π –æ—Ç–≤–µ—Ç, —Ç–∞–∫ –∫–∞–∫ –º—ã —É–∂–µ –æ—Ç–ø—Ä–∞–≤–∏–ª–∏ —Å–æ–æ–±—â–µ–Ω–∏–µ
}

// handleHelp –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –∫–æ–º–∞–Ω–¥—É /help
func (b *Bot) handleHelp(message *tgbotapi.Message, user *database.User) (string, bool) <span class="cov8" title="1">{
        help := `üìñ *–°–ø—Ä–∞–≤–∫–∞ –ø–æ –∫–æ–º–∞–Ω–¥–∞–º*

*–û—Å–Ω–æ–≤–Ω—ã–µ –∫–æ–º–∞–Ω–¥—ã:*
/start - –ù–∞—á–∞—Ç—å —Ä–∞–±–æ—Ç—É —Å –±–æ—Ç–æ–º
/help - –ü–æ–∫–∞–∑–∞—Ç—å —ç—Ç—É —Å–ø—Ä–∞–≤–∫—É
/status - –ü–æ–ª–Ω—ã–π —Å—Ç–∞—Ç—É—Å —Å–∏—Å—Ç–µ–º—ã
/uptime - –í—Ä–µ–º—è —Ä–∞–±–æ—Ç—ã —Å–∏—Å—Ç–µ–º—ã
/history [N] - –ò—Å—Ç–æ—Ä–∏—è –∫–æ–º–∞–Ω–¥ (–ø–æ —É–º–æ–ª—á–∞–Ω–∏—é 10)`

        if user.IsAdmin </span><span class="cov8" title="1">{
                help += `

*–ö–æ–º–∞–Ω–¥—ã –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞:*
/users - –°–ø–∏—Å–æ–∫ –≤—Å–µ—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
/stats - –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –±–æ—Ç–∞
/cleanup [–¥–Ω–∏] - –û—á–∏—Å—Ç–∫–∞ –∏—Å—Ç–æ—Ä–∏–∏ —Å—Ç–∞—Ä—à–µ N –¥–Ω–µ–π (–ø–æ —É–º–æ–ª—á–∞–Ω–∏—é 30)
/addadmin [ID] - –ù–∞–∑–Ω–∞—á–∏—Ç—å –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞
/removeadmin [ID] - –£–±—Ä–∞—Ç—å –ø—Ä–∞–≤–∞ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞
/banuser [ID] - –ó–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
/unbanuser [ID] - –†–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∞—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
/deleteuser [ID] - –£–¥–∞–ª–∏—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è`
        }</span>

        <span class="cov8" title="1">help += `

*–ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è:*
‚Ä¢ –í—Å–µ –∫–æ–º–∞–Ω–¥—ã –∑–∞–ø–∏—Å—ã–≤–∞—é—Ç—Å—è –≤ –∏—Å—Ç–æ—Ä–∏—é
‚Ä¢ –¢–æ–ª—å–∫–æ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω–Ω—ã–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏ –º–æ–≥—É—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –±–æ—Ç–∞
‚Ä¢ –ê–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—ã –∏–º–µ—é—Ç —Ä–∞—Å—à–∏—Ä–µ–Ω–Ω—ã–π –¥–æ—Å—Ç—É–ø`

        return help, true</span>
}

// handleStatus –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –∫–æ–º–∞–Ω–¥—É /status
func (b *Bot) handleStatus(message *tgbotapi.Message, user *database.User) (string, bool) <span class="cov0" title="0">{
        sysInfo, err := b.systemService.GetSystemInfo()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Sprintf("‚ùå –û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ —Å–∏—Å—Ç–µ–º–µ: %v", err), false
        }</span>

        <span class="cov0" title="0">response := "üíª *–°—Ç–∞—Ç—É—Å —Å–∏—Å—Ç–µ–º—ã*\n\n"

        // –û—Å–Ω–æ–≤–Ω–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è
        response += fmt.Sprintf("üñ•Ô∏è *–•–æ—Å—Ç:* %s\n", sysInfo.Hostname)
        response += fmt.Sprintf("üîß *–û–°:* %s %s\n", sysInfo.OS, sysInfo.Platform)
        response += fmt.Sprintf("‚è∞ *–í—Ä–µ–º—è —Ä–∞–±–æ—Ç—ã:* %s\n", formatDuration(sysInfo.Uptime))
        response += fmt.Sprintf("üîÑ *–ü—Ä–æ—Ü–µ—Å—Å–æ–≤:* %d\n\n", sysInfo.ProcessCount)

        // –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ CPU
        response += "üß† *–ü—Ä–æ—Ü–µ—Å—Å–æ—Ä:*\n"
        response += fmt.Sprintf("   ‚Ä¢ –ú–æ–¥–µ–ª—å: %s\n", sysInfo.CPUInfo.ModelName)
        response += fmt.Sprintf("   ‚Ä¢ –Ø–¥–µ—Ä: %d\n", sysInfo.CPUInfo.Cores)
        if len(sysInfo.CPUInfo.Usage) &gt; 0 </span><span class="cov0" title="0">{
                avgUsage := 0.0
                for _, usage := range sysInfo.CPUInfo.Usage </span><span class="cov0" title="0">{
                        avgUsage += usage
                }</span>
                <span class="cov0" title="0">avgUsage /= float64(len(sysInfo.CPUInfo.Usage))
                response += fmt.Sprintf("   ‚Ä¢ –ó–∞–≥—Ä—É–∑–∫–∞: %.1f%%\n", avgUsage)</span>
        }
        <span class="cov0" title="0">if sysInfo.CPUInfo.Temperature &gt; 0 </span><span class="cov0" title="0">{
                response += fmt.Sprintf("   ‚Ä¢ –¢–µ–º–ø–µ—Ä–∞—Ç—É—Ä–∞: %.1f¬∞C\n", sysInfo.CPUInfo.Temperature)
        }</span>
        <span class="cov0" title="0">response += "\n"

        // –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –ø–∞–º—è—Ç–∏
        response += "üßÆ *–ü–∞–º—è—Ç—å:*\n"
        response += fmt.Sprintf("   ‚Ä¢ –í—Å–µ–≥–æ: %s\n", system.FormatBytes(sysInfo.MemoryInfo.Total))
        response += fmt.Sprintf("   ‚Ä¢ –ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è: %s (%.1f%%)\n",
                system.FormatBytes(sysInfo.MemoryInfo.Used), sysInfo.MemoryInfo.UsedPercent)
        response += fmt.Sprintf("   ‚Ä¢ –î–æ—Å—Ç—É–ø–Ω–æ: %s\n\n", system.FormatBytes(sysInfo.MemoryInfo.Available))

        // –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –¥–∏—Å–∫–∞—Ö
        response += "üíæ *–î–∏—Å–∫–∏:*\n"
        for _, disk := range sysInfo.DiskInfo </span><span class="cov0" title="0">{
                if disk.Total &gt; 0 </span><span class="cov0" title="0">{
                        response += fmt.Sprintf("   ‚Ä¢ %s (%s)\n", disk.Device, disk.Fstype)
                        response += fmt.Sprintf("     –í—Å–µ–≥–æ: %s | –°–≤–æ–±–æ–¥–Ω–æ: %s (%.1f%%)\n",
                                system.FormatBytes(disk.Total), system.FormatBytes(disk.Free), 100-disk.UsedPercent)
                }</span>
        }

        // –°–µ—Ç–µ–≤–∞—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ (–ø–æ–∫–∞–∑—ã–≤–∞–µ–º —Ç–æ–ª—å–∫–æ –∞–∫—Ç–∏–≤–Ω—ã–µ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å—ã)
        <span class="cov0" title="0">activeInterfaces := 0
        for _, net := range sysInfo.NetworkInfo </span><span class="cov0" title="0">{
                if net.BytesSent &gt; 0 || net.BytesRecv &gt; 0 </span><span class="cov0" title="0">{
                        activeInterfaces++
                }</span>
        }

        <span class="cov0" title="0">if activeInterfaces &gt; 0 </span><span class="cov0" title="0">{
                response += "\nüåê *–°–µ—Ç—å (–∞–∫—Ç–∏–≤–Ω—ã–µ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å—ã):*\n"
                for _, net := range sysInfo.NetworkInfo </span><span class="cov0" title="0">{
                        if net.BytesSent &gt; 0 || net.BytesRecv &gt; 0 </span><span class="cov0" title="0">{
                                response += fmt.Sprintf("   ‚Ä¢ %s\n", net.Name)
                                response += fmt.Sprintf("     –û—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ: %s | –ü–æ–ª—É—á–µ–Ω–æ: %s\n",
                                        system.FormatBytes(net.BytesSent), system.FormatBytes(net.BytesRecv))
                        }</span>
                }
        }

        <span class="cov0" title="0">return response, true</span>
}
func (b *Bot) handleUptime(message *tgbotapi.Message, user *database.User) (string, bool) <span class="cov8" title="1">{
        return b.handleUptimeInternal(user)
}</span>

func (b *Bot) handleUptimeInternal(user *database.User) (string, bool) <span class="cov8" title="1">{
        uptime, err := b.systemService.GetUptime()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Sprintf("‚ùå –û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –≤—Ä–µ–º–µ–Ω–∏ —Ä–∞–±–æ—Ç—ã: %v", err), false
        }</span>

        <span class="cov8" title="1">return fmt.Sprintf("‚è∞ *–í—Ä–µ–º—è —Ä–∞–±–æ—Ç—ã —Å–∏—Å—Ç–µ–º—ã:* %s", formatDuration(uptime)), true</span>
}

// handleHistory –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –∫–æ–º–∞–Ω–¥—É /history
func (b *Bot) handleHistory(message *tgbotapi.Message, user *database.User, args string) (string, bool) <span class="cov8" title="1">{
        limit := 10
        if args != "" </span><span class="cov8" title="1">{
                if n, err := parseLimit(args); err == nil &amp;&amp; n &gt; 0 &amp;&amp; n &lt;= 50 </span><span class="cov8" title="1">{
                        limit = n
                }</span>
        }

        <span class="cov8" title="1">history, err := b.authMw.GetUserHistory(user.ID, limit)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Sprintf("‚ùå –û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –∏—Å—Ç–æ—Ä–∏–∏: %v", err), false
        }</span>

        <span class="cov8" title="1">if len(history) == 0 </span><span class="cov0" title="0">{
                return "üìù –ò—Å—Ç–æ—Ä–∏—è –∫–æ–º–∞–Ω–¥ –ø—É—Å—Ç–∞", true
        }</span>

        <span class="cov8" title="1">response := fmt.Sprintf("üìù *–ò—Å—Ç–æ—Ä–∏—è –∫–æ–º–∞–Ω–¥* (–ø–æ—Å–ª–µ–¥–Ω–∏–µ %d):\n\n", len(history))
        for i, cmd := range history </span><span class="cov8" title="1">{
                status := "‚úÖ"
                if !cmd.Success </span><span class="cov0" title="0">{
                        status = "‚ùå"
                }</span>
                <span class="cov8" title="1">response += fmt.Sprintf("%d. %s `/%s %s`\n   _–í—Ä–µ–º—è: %s_\n\n",
                        i+1, status, cmd.Command, cmd.Arguments, cmd.ExecutedAt.Format("02.01.2006 15:04:05"))</span>
        }

        <span class="cov8" title="1">return response, true</span>
}

// handleUsers –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –∫–æ–º–∞–Ω–¥—É /users (—Ç–æ–ª—å–∫–æ –∞–¥–º–∏–Ω—ã)
func (b *Bot) handleUsers(message *tgbotapi.Message, user *database.User) (string, bool) <span class="cov8" title="1">{
        if !user.IsAdmin </span><span class="cov8" title="1">{
                return "‚ùå –î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â–µ–Ω. –¢—Ä–µ–±—É—é—Ç—Å—è –ø—Ä–∞–≤–∞ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞.", false
        }</span>

        <span class="cov8" title="1">users, err := b.authMw.GetAllUsers(user.ID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Sprintf("‚ùå –û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Å–ø–∏—Å–∫–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π: %v", err), false
        }</span>

        <span class="cov8" title="1">if len(users) == 0 </span><span class="cov0" title="0">{
                return "üë• –°–ø–∏—Å–æ–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –ø—É—Å—Ç", true
        }</span>

        <span class="cov8" title="1">response := "üë• *–°–ø–∏—Å–æ–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π:*\n\n"
        for i, u := range users </span><span class="cov8" title="1">{
                status := "üü¢"
                if !u.IsActive </span><span class="cov0" title="0">{
                        status = "üî¥"
                }</span>
                <span class="cov8" title="1">role := "–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å"
                if u.IsAdmin </span><span class="cov8" title="1">{
                        role = "–ê–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä"
                }</span>
                <span class="cov8" title="1">response += fmt.Sprintf("%d. %s *%s %s* (@%s)\n   ID: %d | %s\n   –°–æ–∑–¥–∞–Ω: %s\n\n",
                        i+1, status, u.FirstName, u.LastName, u.Username, u.ID, role,
                        u.CreatedAt.Format("02.01.2006 15:04"))</span>
        }

        <span class="cov8" title="1">return response, true</span>
}

// handleStats –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –∫–æ–º–∞–Ω–¥—É /stats (—Ç–æ–ª—å–∫–æ –∞–¥–º–∏–Ω—ã)
func (b *Bot) handleStats(message *tgbotapi.Message, user *database.User) (string, bool) <span class="cov8" title="1">{
        if !user.IsAdmin </span><span class="cov8" title="1">{
                return "‚ùå –î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â–µ–Ω. –¢—Ä–µ–±—É—é—Ç—Å—è –ø—Ä–∞–≤–∞ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞.", false
        }</span>

        <span class="cov8" title="1">stats, err := b.authMw.GetStats(user.ID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Sprintf("‚ùå –û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏: %v", err), false
        }</span>

        <span class="cov8" title="1">response := "üìä *–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è:*\n\n"
        response += fmt.Sprintf("üë• –í—Å–µ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π: %v\n", stats["total_users"])
        response += fmt.Sprintf("üü¢ –ê–∫—Ç–∏–≤–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π: %v\n", stats["active_users"])
        response += fmt.Sprintf("üìù –í—Å–µ–≥–æ –∫–æ–º–∞–Ω–¥: %v\n", stats["total_commands"])
        response += fmt.Sprintf("‚úÖ –£—Å–ø–µ—à–Ω—ã—Ö –∫–æ–º–∞–Ω–¥: %v\n", stats["successful_commands"])
        response += fmt.Sprintf("üïê –ö–æ–º–∞–Ω–¥ –∑–∞ 24 —á–∞—Å–∞: %v\n", stats["recent_commands"])

        // –î–æ–±–∞–≤–ª—è–µ–º –ø—Ä–æ—Ü–µ–Ω—Ç —É—Å–ø–µ—à–Ω–æ—Å—Ç–∏
        if total := stats["total_commands"].(int); total &gt; 0 </span><span class="cov0" title="0">{
                successful := stats["successful_commands"].(int)
                successRate := float64(successful) * 100 / float64(total)
                response += fmt.Sprintf("üìà –ü—Ä–æ—Ü–µ–Ω—Ç —É—Å–ø–µ—à–Ω–æ—Å—Ç–∏: %.1f%%", successRate)
        }</span>

        <span class="cov8" title="1">return response, true</span>
}

// handleCleanup –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –∫–æ–º–∞–Ω–¥—É /cleanup (—Ç–æ–ª—å–∫–æ –∞–¥–º–∏–Ω—ã)
func (b *Bot) handleCleanup(message *tgbotapi.Message, user *database.User, args string) (string, bool) <span class="cov8" title="1">{
        if !user.IsAdmin </span><span class="cov8" title="1">{
                return "‚ùå –î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â–µ–Ω. –¢—Ä–µ–±—É—é—Ç—Å—è –ø—Ä–∞–≤–∞ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞.", false
        }</span>

        <span class="cov8" title="1">days := 30
        if args != "" </span><span class="cov8" title="1">{
                if n, err := parseLimit(args); err == nil &amp;&amp; n &gt; 0 &amp;&amp; n &lt;= 365 </span><span class="cov8" title="1">{
                        days = n
                }</span>
        }

        <span class="cov8" title="1">err := b.authMw.CleanupOldData(user.ID, days)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Sprintf("‚ùå –û—à–∏–±–∫–∞ –æ—á–∏—Å—Ç–∫–∏ –¥–∞–Ω–Ω—ã—Ö: %v", err), false
        }</span>

        <span class="cov8" title="1">return fmt.Sprintf("üßπ –û—á–∏—Å—Ç–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞. –£–¥–∞–ª–µ–Ω—ã –∑–∞–ø–∏—Å–∏ —Å—Ç–∞—Ä—à–µ %d –¥–Ω–µ–π.", days), true</span>
}

// –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏

// formatDuration —Ñ–æ—Ä–º–∞—Ç–∏—Ä—É–µ—Ç –ø—Ä–æ–¥–æ–ª–∂–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å –≤ —á–∏—Ç–∞–µ–º—ã–π –≤–∏–¥
func formatDuration(d time.Duration) string <span class="cov8" title="1">{
        days := int(d.Hours()) / 24
        hours := int(d.Hours()) % 24
        minutes := int(d.Minutes()) % 60

        if days &gt; 0 </span><span class="cov8" title="1">{
                return fmt.Sprintf("%d –¥–Ω. %d —á. %d –º–∏–Ω.", days, hours, minutes)
        }</span>
        <span class="cov8" title="1">if hours &gt; 0 </span><span class="cov8" title="1">{
                return fmt.Sprintf("%d —á. %d –º–∏–Ω.", hours, minutes)
        }</span>
        <span class="cov8" title="1">return fmt.Sprintf("%d –º–∏–Ω.", minutes)</span>
}

// parseLimit –ø–∞—Ä—Å–∏—Ç —Å—Ç—Ä–æ–∫—É –≤ —á–∏—Å–ª–æ
func parseLimit(s string) (int, error) <span class="cov8" title="1">{
        var n int
        _, err := fmt.Sscanf(strings.TrimSpace(s), "%d", &amp;n)
        return n, err
}</span>

// handleAddAdmin –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –∫–æ–º–∞–Ω–¥—É /addadmin (—Ç–æ–ª—å–∫–æ –∞–¥–º–∏–Ω—ã)
func (b *Bot) handleAddAdmin(message *tgbotapi.Message, user *database.User, args string) (string, bool) <span class="cov8" title="1">{
        if !user.IsAdmin </span><span class="cov0" title="0">{
                return "‚ùå –î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â–µ–Ω. –¢—Ä–µ–±—É—é—Ç—Å—è –ø—Ä–∞–≤–∞ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞.", false
        }</span>

        <span class="cov8" title="1">if args == "" </span><span class="cov8" title="1">{
                return "‚ùå –ù–µ–æ–±—Ö–æ–¥–∏–º–æ —É–∫–∞–∑–∞—Ç—å ID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è. –ü—Ä–∏–º–µ—Ä: /addadmin 123456789", false
        }</span>

        <span class="cov8" title="1">userID, err := parseUserID(args)
        if err != nil </span><span class="cov8" title="1">{
                return "‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π ID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è", false
        }</span>

        <span class="cov8" title="1">err = b.authMw.SetUserAdmin(user.ID, userID, true)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Sprintf("‚ùå –û—à–∏–±–∫–∞: %v", err), false
        }</span>

        <span class="cov8" title="1">return fmt.Sprintf("‚úÖ –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å %d –Ω–∞–∑–Ω–∞—á–µ–Ω –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–æ–º", userID), true</span>
}

// handleRemoveAdmin –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –∫–æ–º–∞–Ω–¥—É /removeadmin (—Ç–æ–ª—å–∫–æ –∞–¥–º–∏–Ω—ã)
func (b *Bot) handleRemoveAdmin(message *tgbotapi.Message, user *database.User, args string) (string, bool) <span class="cov8" title="1">{
        if !user.IsAdmin </span><span class="cov0" title="0">{
                return "‚ùå –î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â–µ–Ω. –¢—Ä–µ–±—É—é—Ç—Å—è –ø—Ä–∞–≤–∞ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞.", false
        }</span>

        <span class="cov8" title="1">if args == "" </span><span class="cov0" title="0">{
                return "‚ùå –ù–µ–æ–±—Ö–æ–¥–∏–º–æ —É–∫–∞–∑–∞—Ç—å ID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è. –ü—Ä–∏–º–µ—Ä: /removeadmin 123456789", false
        }</span>

        <span class="cov8" title="1">userID, err := parseUserID(args)
        if err != nil </span><span class="cov0" title="0">{
                return "‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π ID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è", false
        }</span>

        <span class="cov8" title="1">if userID == user.ID </span><span class="cov8" title="1">{
                return "‚ùå –ù–µ–ª—å–∑—è —É–±—Ä–∞—Ç—å –ø—Ä–∞–≤–∞ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞ —É —Å–µ–±—è", false
        }</span>

        <span class="cov8" title="1">err = b.authMw.SetUserAdmin(user.ID, userID, false)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Sprintf("‚ùå –û—à–∏–±–∫–∞: %v", err), false
        }</span>

        <span class="cov8" title="1">return fmt.Sprintf("‚úÖ –ü—Ä–∞–≤–∞ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞ —É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è %d —É–±—Ä–∞–Ω—ã", userID), true</span>
}

// handleBanUser –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –∫–æ–º–∞–Ω–¥—É /banuser (—Ç–æ–ª—å–∫–æ –∞–¥–º–∏–Ω—ã)
func (b *Bot) handleBanUser(message *tgbotapi.Message, user *database.User, args string) (string, bool) <span class="cov8" title="1">{
        if !user.IsAdmin </span><span class="cov0" title="0">{
                return "‚ùå –î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â–µ–Ω. –¢—Ä–µ–±—É—é—Ç—Å—è –ø—Ä–∞–≤–∞ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞.", false
        }</span>

        <span class="cov8" title="1">if args == "" </span><span class="cov0" title="0">{
                return "‚ùå –ù–µ–æ–±—Ö–æ–¥–∏–º–æ —É–∫–∞–∑–∞—Ç—å ID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è. –ü—Ä–∏–º–µ—Ä: /banuser 123456789", false
        }</span>

        <span class="cov8" title="1">userID, err := parseUserID(args)
        if err != nil </span><span class="cov0" title="0">{
                return "‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π ID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è", false
        }</span>

        <span class="cov8" title="1">if userID == user.ID </span><span class="cov8" title="1">{
                return "‚ùå –ù–µ–ª—å–∑—è –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞—Ç—å —Å–µ–±—è", false
        }</span>

        <span class="cov8" title="1">err = b.authMw.SetUserActive(user.ID, userID, false)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Sprintf("‚ùå –û—à–∏–±–∫–∞: %v", err), false
        }</span>

        <span class="cov8" title="1">return fmt.Sprintf("‚úÖ –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å %d –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω", userID), true</span>
}

// handleUnbanUser –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –∫–æ–º–∞–Ω–¥—É /unbanuser (—Ç–æ–ª—å–∫–æ –∞–¥–º–∏–Ω—ã)
func (b *Bot) handleUnbanUser(message *tgbotapi.Message, user *database.User, args string) (string, bool) <span class="cov8" title="1">{
        if !user.IsAdmin </span><span class="cov0" title="0">{
                return "‚ùå –î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â–µ–Ω. –¢—Ä–µ–±—É—é—Ç—Å—è –ø—Ä–∞–≤–∞ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞.", false
        }</span>

        <span class="cov8" title="1">if args == "" </span><span class="cov0" title="0">{
                return "‚ùå –ù–µ–æ–±—Ö–æ–¥–∏–º–æ —É–∫–∞–∑–∞—Ç—å ID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è. –ü—Ä–∏–º–µ—Ä: /unbanuser 123456789", false
        }</span>

        <span class="cov8" title="1">userID, err := parseUserID(args)
        if err != nil </span><span class="cov0" title="0">{
                return "‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π ID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è", false
        }</span>

        <span class="cov8" title="1">err = b.authMw.SetUserActive(user.ID, userID, true)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Sprintf("‚ùå –û—à–∏–±–∫–∞: %v", err), false
        }</span>

        <span class="cov8" title="1">return fmt.Sprintf("‚úÖ –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å %d —Ä–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω", userID), true</span>
}

// handleDeleteUser –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –∫–æ–º–∞–Ω–¥—É /deleteuser (—Ç–æ–ª—å–∫–æ –∞–¥–º–∏–Ω—ã)
func (b *Bot) handleDeleteUser(message *tgbotapi.Message, user *database.User, args string) (string, bool) <span class="cov8" title="1">{
        if !user.IsAdmin </span><span class="cov0" title="0">{
                return "‚ùå –î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â–µ–Ω. –¢—Ä–µ–±—É—é—Ç—Å—è –ø—Ä–∞–≤–∞ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞.", false
        }</span>

        <span class="cov8" title="1">if args == "" </span><span class="cov0" title="0">{
                return "‚ùå –ù–µ–æ–±—Ö–æ–¥–∏–º–æ —É–∫–∞–∑–∞—Ç—å ID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è. –ü—Ä–∏–º–µ—Ä: /deleteuser 123456789", false
        }</span>

        <span class="cov8" title="1">userID, err := parseUserID(args)
        if err != nil </span><span class="cov0" title="0">{
                return "‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π ID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è", false
        }</span>

        <span class="cov8" title="1">if userID == user.ID </span><span class="cov8" title="1">{
                return "‚ùå –ù–µ–ª—å–∑—è —É–¥–∞–ª–∏—Ç—å —Å–µ–±—è", false
        }</span>

        <span class="cov8" title="1">err = b.authMw.DeleteUser(user.ID, userID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Sprintf("‚ùå –û—à–∏–±–∫–∞: %v", err), false
        }</span>

        <span class="cov8" title="1">return fmt.Sprintf("‚úÖ –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å %d —É–¥–∞–ª–µ–Ω", userID), true</span>
}

// parseUserID –ø–∞—Ä—Å–∏—Ç ID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∏–∑ —Å—Ç—Ä–æ–∫–∏
func parseUserID(s string) (int64, error) <span class="cov8" title="1">{
        var userID int64
        _, err := fmt.Sscanf(strings.TrimSpace(s), "%d", &amp;userID)
        return userID, err
}</span>

// getMainKeyboard returns the main keyboard
func (b *Bot) getMainKeyboard(isAdmin bool) tgbotapi.InlineKeyboardMarkup <span class="cov8" title="1">{
        var rows [][]tgbotapi.InlineKeyboardButton

        // Basic buttons
        rows = append(rows, []tgbotapi.InlineKeyboardButton{
                tgbotapi.NewInlineKeyboardButtonData("üíª System Status", "status"),
                tgbotapi.NewInlineKeyboardButtonData("‚è∞ Uptime", "uptime"),
        })

        rows = append(rows, []tgbotapi.InlineKeyboardButton{
                tgbotapi.NewInlineKeyboardButtonData("üìù Command History", "history"),
        })

        // Admin buttons
        if isAdmin </span><span class="cov8" title="1">{
                rows = append(rows, []tgbotapi.InlineKeyboardButton{
                        tgbotapi.NewInlineKeyboardButtonData("üë• Users", "users"),
                        tgbotapi.NewInlineKeyboardButtonData("üìä Statistics", "stats"),
                })
        }</span>

        <span class="cov8" title="1">return tgbotapi.NewInlineKeyboardMarkup(rows...)</span>
}

// Callback handlers
func (b *Bot) handleStatusCallback(user *database.User) (string, bool) <span class="cov0" title="0">{
        return b.handleStatusInternal(user)
}</span>

func (b *Bot) handleUptimeCallback(user *database.User) (string, bool) <span class="cov0" title="0">{
        return b.handleUptimeInternal(user)
}</span>

func (b *Bot) handleHistoryCallback(user *database.User) (string, bool) <span class="cov0" title="0">{
        return b.handleHistoryInternal(user, "")
}</span>

func (b *Bot) handleUsersCallback(user *database.User) (string, bool) <span class="cov0" title="0">{
        return b.handleUsersInternal(user)
}</span>

func (b *Bot) handleStatsCallback(user *database.User) (string, bool) <span class="cov0" title="0">{
        return b.handleStatsInternal(user)
}</span>

func (b *Bot) handleAdminMenuCallback(user *database.User) (string, bool) <span class="cov0" title="0">{
        if !user.IsAdmin </span><span class="cov0" title="0">{
                return "‚ùå Access denied", false
        }</span>
        <span class="cov0" title="0">return "üîë *Admin Menu*\n\nSelect an action:", true</span>
}

func (b *Bot) handleMainMenuCallback(user *database.User) (string, bool) <span class="cov0" title="0">{
        return fmt.Sprintf("üè† *Main Menu*\n\nHello, %s! Choose an action:", user.FirstName), true
}</span>

// Missing internal handler methods
func (b *Bot) handleStatusInternal(user *database.User) (string, bool) <span class="cov0" title="0">{
        return b.handleStatus(nil, user)
}</span>

func (b *Bot) handleHistoryInternal(user *database.User, args string) (string, bool) <span class="cov0" title="0">{
        return b.handleHistory(nil, user, args)
}</span>

func (b *Bot) handleUsersInternal(user *database.User) (string, bool) <span class="cov0" title="0">{
        return b.handleUsers(nil, user)
}</span>

func (b *Bot) handleStatsInternal(user *database.User) (string, bool) <span class="cov0" title="0">{
        return b.handleStats(nil, user)
}</span>

// getAdminKeyboard returns admin-specific keyboard
func (b *Bot) getAdminKeyboard() tgbotapi.InlineKeyboardMarkup <span class="cov0" title="0">{
        rows := [][]tgbotapi.InlineKeyboardButton{
                {
                        tgbotapi.NewInlineKeyboardButtonData("üë• Manage Users", "users"),
                        tgbotapi.NewInlineKeyboardButtonData("üìä View Stats", "stats"),
                },
                {
                        tgbotapi.NewInlineKeyboardButtonData("üè† Main Menu", "main_menu"),
                },
        }
        return tgbotapi.NewInlineKeyboardMarkup(rows...)
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package config

import (
        "fmt"
        "os"
        "strconv"
        "strings"

        "gopkg.in/yaml.v3"
)

type Config struct {
        Bot      BotConfig      `yaml:"bot"`
        Database DatabaseConfig `yaml:"database"`
        Users    UsersConfig    `yaml:"users"`
}

type BotConfig struct {
        Token string `yaml:"token"`
        Debug bool   `yaml:"debug"`
}

type DatabaseConfig struct {
        Path string `yaml:"path"`
}

type UsersConfig struct {
        AdminUserIDs []int64 `yaml:"admin_user_ids"`
        AllowedUsers []int64 `yaml:"allowed_users"`
}

func Load(configPath string) (*Config, error) <span class="cov8" title="1">{
        // –°–Ω–∞—á–∞–ª–∞ –∑–∞–≥—Ä—É–∂–∞–µ–º –∏–∑ —Ñ–∞–π–ª–∞
        config := &amp;Config{}

        if _, err := os.Stat(configPath); err == nil </span><span class="cov8" title="1">{
                data, err := os.ReadFile(configPath)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to read config file: %w", err)
                }</span>

                <span class="cov8" title="1">if err := yaml.Unmarshal(data, config); err != nil </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("failed to parse config file: %w", err)
                }</span>
        }

        // –ü–µ—Ä–µ–æ–ø—Ä–µ–¥–µ–ª—è–µ–º –∑–Ω–∞—á–µ–Ω–∏—è –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–º–∏ –æ–∫—Ä—É–∂–µ–Ω–∏—è
        <span class="cov8" title="1">if token := os.Getenv("BOT_TOKEN"); token != "" </span><span class="cov8" title="1">{
                config.Bot.Token = token
        }</span>

        <span class="cov8" title="1">if debug := os.Getenv("BOT_DEBUG"); debug != "" </span><span class="cov8" title="1">{
                config.Bot.Debug = debug == "true"
        }</span>

        <span class="cov8" title="1">if dbPath := os.Getenv("DB_PATH"); dbPath != "" </span><span class="cov8" title="1">{
                config.Database.Path = dbPath
        }</span>

        <span class="cov8" title="1">if adminIDs := os.Getenv("ADMIN_USER_IDS"); adminIDs != "" </span><span class="cov8" title="1">{
                ids := parseUserIDs(adminIDs)
                if len(ids) &gt; 0 </span><span class="cov8" title="1">{
                        config.Users.AdminUserIDs = ids
                }</span>
        }

        <span class="cov8" title="1">if allowedIDs := os.Getenv("ALLOWED_USER_IDS"); allowedIDs != "" </span><span class="cov8" title="1">{
                ids := parseUserIDs(allowedIDs)
                if len(ids) &gt; 0 </span><span class="cov8" title="1">{
                        config.Users.AllowedUsers = ids
                }</span>
        }

        // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –∑–Ω–∞—á–µ–Ω–∏—è –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
        <span class="cov8" title="1">if config.Database.Path == "" </span><span class="cov8" title="1">{
                config.Database.Path = "cupbot.db"
        }</span>

        <span class="cov8" title="1">return config, nil</span>
}

func parseUserIDs(s string) []int64 <span class="cov8" title="1">{
        parts := strings.Split(s, ",")
        var ids []int64

        for _, part := range parts </span><span class="cov8" title="1">{
                part = strings.TrimSpace(part)
                if id, err := strconv.ParseInt(part, 10, 64); err == nil </span><span class="cov8" title="1">{
                        ids = append(ids, id)
                }</span>
        }

        <span class="cov8" title="1">return ids</span>
}

func (c *Config) IsAdmin(userID int64) bool <span class="cov8" title="1">{
        for _, id := range c.Users.AdminUserIDs </span><span class="cov8" title="1">{
                if id == userID </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

func (c *Config) IsAllowed(userID int64) bool <span class="cov8" title="1">{
        // –ê–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—ã –≤—Å–µ–≥–¥–∞ —Ä–∞–∑—Ä–µ—à–µ–Ω—ã
        if c.IsAdmin(userID) </span><span class="cov8" title="1">{
                return true
        }</span>

        // –ï—Å–ª–∏ —Å–ø–∏—Å–æ–∫ —Ä–∞–∑—Ä–µ—à–µ–Ω–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –ø—É—Å—Ç, —Ç–æ —Ä–∞–∑—Ä–µ—à–µ–Ω—ã —Ç–æ–ª—å–∫–æ –∞–¥–º–∏–Ω—ã
        <span class="cov8" title="1">if len(c.Users.AllowedUsers) == 0 </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">for _, id := range c.Users.AllowedUsers </span><span class="cov8" title="1">{
                if id == userID </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package system

import (
        "fmt"
        "runtime"
        "time"

        "github.com/shirou/gopsutil/v3/cpu"
        "github.com/shirou/gopsutil/v3/disk"
        "github.com/shirou/gopsutil/v3/host"
        "github.com/shirou/gopsutil/v3/load"
        "github.com/shirou/gopsutil/v3/mem"
        "github.com/shirou/gopsutil/v3/net"
)

// SystemInfo —Å–æ–¥–µ—Ä–∂–∏—Ç –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ —Å–∏—Å—Ç–µ–º–µ
type SystemInfo struct {
        Hostname     string        `json:"hostname"`
        OS           string        `json:"os"`
        Platform     string        `json:"platform"`
        Uptime       time.Duration `json:"uptime"`
        BootTime     time.Time     `json:"boot_time"`
        CPUInfo      CPUInfo       `json:"cpu_info"`
        MemoryInfo   MemoryInfo    `json:"memory_info"`
        DiskInfo     []DiskInfo    `json:"disk_info"`
        NetworkInfo  []NetworkInfo `json:"network_info"`
        ProcessCount uint64        `json:"process_count"`
}

type CPUInfo struct {
        ModelName   string    `json:"model_name"`
        Cores       int       `json:"cores"`
        Usage       []float64 `json:"usage"`
        Temperature float64   `json:"temperature"`
}

type MemoryInfo struct {
        Total       uint64  `json:"total"`
        Available   uint64  `json:"available"`
        Used        uint64  `json:"used"`
        UsedPercent float64 `json:"used_percent"`
}

type DiskInfo struct {
        Device      string  `json:"device"`
        Mountpoint  string  `json:"mountpoint"`
        Fstype      string  `json:"fstype"`
        Total       uint64  `json:"total"`
        Free        uint64  `json:"free"`
        Used        uint64  `json:"used"`
        UsedPercent float64 `json:"used_percent"`
}

type NetworkInfo struct {
        Name      string `json:"name"`
        BytesSent uint64 `json:"bytes_sent"`
        BytesRecv uint64 `json:"bytes_recv"`
}

// Service –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª—è–µ—Ç –º–µ—Ç–æ–¥—ã –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è —Å–∏—Å—Ç–µ–º–Ω–æ–π –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏
type Service struct{}

// NewService —Å–æ–∑–¥–∞–µ—Ç –Ω–æ–≤—ã–π —ç–∫–∑–µ–º–ø–ª—è—Ä —Å–µ—Ä–≤–∏—Å–∞
func NewService() *Service <span class="cov8" title="1">{
        return &amp;Service{}
}</span>

// GetSystemInfo –ø–æ–ª—É—á–∞–µ—Ç –ø–æ–ª–Ω—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ —Å–∏—Å—Ç–µ–º–µ
func (s *Service) GetSystemInfo() (*SystemInfo, error) <span class="cov8" title="1">{
        info := &amp;SystemInfo{}

        // –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ —Ö–æ—Å—Ç–µ
        hostInfo, err := host.Info()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get host info: %w", err)
        }</span>

        <span class="cov8" title="1">info.Hostname = hostInfo.Hostname
        info.OS = hostInfo.OS
        info.Platform = hostInfo.Platform
        info.Uptime = time.Duration(hostInfo.Uptime) * time.Second
        info.BootTime = time.Unix(int64(hostInfo.BootTime), 0)
        info.ProcessCount = hostInfo.Procs

        // –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ CPU
        cpuInfo, err := s.getCPUInfo()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get CPU info: %w", err)
        }</span>
        <span class="cov8" title="1">info.CPUInfo = *cpuInfo

        // –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –ø–∞–º—è—Ç–∏
        memInfo, err := s.getMemoryInfo()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get memory info: %w", err)
        }</span>
        <span class="cov8" title="1">info.MemoryInfo = *memInfo

        // –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –¥–∏—Å–∫–∞—Ö
        diskInfo, err := s.getDiskInfo()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get disk info: %w", err)
        }</span>
        <span class="cov8" title="1">info.DiskInfo = diskInfo

        // –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ —Å–µ—Ç–∏
        netInfo, err := s.getNetworkInfo()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get network info: %w", err)
        }</span>
        <span class="cov8" title="1">info.NetworkInfo = netInfo

        return info, nil</span>
}

func (s *Service) getCPUInfo() (*CPUInfo, error) <span class="cov8" title="1">{
        cpuInfos, err := cpu.Info()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">info := &amp;CPUInfo{
                Cores: runtime.NumCPU(),
        }

        if len(cpuInfos) &gt; 0 </span><span class="cov8" title="1">{
                info.ModelName = cpuInfos[0].ModelName
        }</span>

        // –ü–æ–ª—É—á–µ–Ω–∏–µ –∑–∞–≥—Ä—É–∑–∫–∏ CPU
        <span class="cov8" title="1">percentages, err := cpu.Percent(time.Second, true)
        if err == nil </span><span class="cov8" title="1">{
                info.Usage = percentages
        }</span>

        // –ü–æ–ø—ã—Ç–∫–∞ –ø–æ–ª—É—á–∏—Ç—å —Ç–µ–º–ø–µ—Ä–∞—Ç—É—Ä—É (–º–æ–∂–µ—Ç –Ω–µ —Ä–∞–±–æ—Ç–∞—Ç—å –Ω–∞ Windows)
        <span class="cov8" title="1">temps, err := host.SensorsTemperatures()
        if err == nil &amp;&amp; len(temps) &gt; 0 </span><span class="cov0" title="0">{
                for _, temp := range temps </span><span class="cov0" title="0">{
                        if temp.SensorKey == "cpu" </span><span class="cov0" title="0">{
                                info.Temperature = temp.Temperature
                                break</span>
                        }
                }
        }

        <span class="cov8" title="1">return info, nil</span>
}

func (s *Service) getMemoryInfo() (*MemoryInfo, error) <span class="cov8" title="1">{
        memStat, err := mem.VirtualMemory()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;MemoryInfo{
                Total:       memStat.Total,
                Available:   memStat.Available,
                Used:        memStat.Used,
                UsedPercent: memStat.UsedPercent,
        }, nil</span>
}

func (s *Service) getDiskInfo() ([]DiskInfo, error) <span class="cov8" title="1">{
        partitions, err := disk.Partitions(false)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var diskInfos []DiskInfo
        for _, partition := range partitions </span><span class="cov8" title="1">{
                usage, err := disk.Usage(partition.Mountpoint)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">diskInfos = append(diskInfos, DiskInfo{
                        Device:      partition.Device,
                        Mountpoint:  partition.Mountpoint,
                        Fstype:      partition.Fstype,
                        Total:       usage.Total,
                        Free:        usage.Free,
                        Used:        usage.Used,
                        UsedPercent: usage.UsedPercent,
                })</span>
        }

        <span class="cov8" title="1">return diskInfos, nil</span>
}

func (s *Service) getNetworkInfo() ([]NetworkInfo, error) <span class="cov8" title="1">{
        netStats, err := net.IOCounters(true)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var netInfos []NetworkInfo
        for _, stat := range netStats </span><span class="cov8" title="1">{
                netInfos = append(netInfos, NetworkInfo{
                        Name:      stat.Name,
                        BytesSent: stat.BytesSent,
                        BytesRecv: stat.BytesRecv,
                })
        }</span>

        <span class="cov8" title="1">return netInfos, nil</span>
}

// GetUptime –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –≤—Ä–µ–º—è —Ä–∞–±–æ—Ç—ã —Å–∏—Å—Ç–µ–º—ã
func (s *Service) GetUptime() (time.Duration, error) <span class="cov8" title="1">{
        hostInfo, err := host.Info()
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov8" title="1">return time.Duration(hostInfo.Uptime) * time.Second, nil</span>
}

// GetLoadAverage –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å—Ä–µ–¥–Ω—é—é –∑–∞–≥—Ä—É–∑–∫—É —Å–∏—Å—Ç–µ–º—ã
func (s *Service) GetLoadAverage() ([]float64, error) <span class="cov8" title="1">{
        loadStat, err := load.Avg()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return []float64{loadStat.Load1, loadStat.Load5, loadStat.Load15}, nil</span>
}

// FormatBytes —Ñ–æ—Ä–º–∞—Ç–∏—Ä—É–µ—Ç –±–∞–π—Ç—ã –≤ —á–∏—Ç–∞–µ–º—ã–π —Ñ–æ—Ä–º–∞—Ç
func FormatBytes(bytes uint64) string <span class="cov8" title="1">{
        const unit = 1024
        if bytes &lt; unit </span><span class="cov8" title="1">{
                return fmt.Sprintf("%d B", bytes)
        }</span>
        <span class="cov8" title="1">div, exp := int64(unit), 0
        for n := bytes / unit; n &gt;= unit; n /= unit </span><span class="cov8" title="1">{
                div *= unit
                exp++
        }</span>
        <span class="cov8" title="1">return fmt.Sprintf("%.1f %cB", float64(bytes)/float64(div), "KMGTPE"[exp])</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
